// <auto-generated>
//  automatically generated by the FlatTables Tool, do not modify
// </auto-generated>

namespace FlatTables
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Reflection;
    using global::Google.FlatBuffers;
    using System.IO;
    using System.IO.Compression;
    
    public interface IConfFileLoader
    {
        public byte[] LoadAllBytes(string fileName);
    }
    
    public interface IConfDisposable
    {
        public void Dispose(bool unRegister = true);
    }
    
    public static partial class ConfManager
    {
        private static readonly HashSet<IConfDisposable> _allDisposable = new HashSet<IConfDisposable>();
        private static IConfFileLoader _confFileLoader = null;
        private static bool _isBinCompressed = false;
        private static bool _useBrotliAlgorithm = true;
    
        public static void SetConfFileLoader(IConfFileLoader confFileLoader, bool isBinCompressed = false, bool useBrotliAlgorithm = true)
        {
            _confFileLoader = confFileLoader;
            _isBinCompressed = isBinCompressed;
            _useBrotliAlgorithm = useBrotliAlgorithm;
        }
    
        public static byte[] LoadConfFile(string fileName)
        {
            var bytes = _confFileLoader?.LoadAllBytes(fileName);
            if (_isBinCompressed && bytes?.Length > 0)
            {
                // Decompress byte array using Brotli
                if (_useBrotliAlgorithm)
                {
                    using var compressedStream = new MemoryStream(bytes);
                    using var resultStream = new MemoryStream();
                    using var brotliStream = new BrotliStream(compressedStream, CompressionMode.Decompress, true);
                    brotliStream.CopyTo(resultStream);
                    bytes = resultStream.ToArray();
                }
                else // Decompress byte array using GZip
                {
                    using var compressedStream = new MemoryStream(bytes);
                    using var resultStream = new MemoryStream();
                    using var zipStream = new GZipStream(compressedStream, CompressionMode.Decompress, true);
                    zipStream.CopyTo(resultStream);
                    bytes = resultStream.ToArray();
                }
            }

            return bytes;
        }
            
        public static void Register(IConfDisposable disposable)
        {
            _allDisposable.Add(disposable);
        }
    
        public static void UnRegister(IConfDisposable disposable)
        {
            _allDisposable.Remove(disposable);
        }
    
        public static void DisposeAll()
        {
            foreach (var disposable in _allDisposable) 
            {
                disposable.Dispose(false);
            }

            _allDisposable.Clear();
            _confFileLoader = null;
        }
        
        public static void Preload(List<string> confClassNameList)
        {
            foreach (var confClassName in confClassNameList)
            {
                var type = Type.GetType($"FlatTables.{confClassName}");
                if (null != type)
                {
                    var method = type.BaseType.GetMethod("Preload", BindingFlags.Public | BindingFlags.Static);
                    if (null != method)
                    {
                        method.Invoke(null,null);
                    }
                }
            }
        }
    }
    
    public abstract class ConfBase<T_Conf, T_Info, T_KEY> : IConfDisposable
        where T_Conf : ConfBase<T_Conf, T_Info, T_KEY>, new()
        where T_Info : struct, IFlatbufferObject
    {
        private static readonly object _lockObject = new object();
        private static T_Conf _instance = null;
        private Dictionary<T_KEY, int> _toi = null;
        private List<T_Info> _list = null;
    
        public static T_Conf Instance
        {
            get
            {
                if (null == _instance)
                {
                    lock (_lockObject)
                    {
                        _instance ??= new T_Conf();
                    }
                }
                return _instance;
            }
        }
        
        public static void Preload()
        {
            _ = Instance;
        }
        
        protected ConfBase()
        {
            ConfManager.Register(this);
            OnCreate();
            OnPostCreated();
        }
        
        public List<T_Info> ListCache
        {
            get
            {
                if (null != _list) 
                {
                    return _list;
                }
    
                _list = new List<T_Info>(Count);
                for (var i = 0; i < Count; i++)
                {
                    var info = GetByIndex(i);
                    if (info.HasValue) 
                    {
                        _list.Add(info.Value);
                    }
                }
    
                return _list;
            }
        }
    
        public int Count { get; protected set; }
    
        public virtual void Dispose(bool unRegister = true)
        {
            _toi?.Clear();
            _toi = null;
            ClearListCache();
            _instance = null;
            if (unRegister)
            {
                ConfManager.UnRegister(this);
            }
        }
    
        public void ClearListCache()
        {
            _list?.Clear();
            _list = null;
        }
    
        public void ForEach(Action<T_Info> action)
        {
            ListCache.ForEach(action);
        }
    
        public T_Info Find(Predicate<T_Info> match)
        {
            return ListCache.Find(match);
        }
    
        public List<T_Info> FindAll(Predicate<T_Info> match)
        {
            return ListCache.FindAll(match);
        }
    
        public int FindAll(List<T_Info> list, Predicate<T_Info> match)
        {
            var listCache = ListCache;
            foreach (var info in listCache)
            {
                if (match(info))
                {
                   list.Add(info);
                }
            }

            return list.Count;
        }
    
        protected ByteBuffer GetBuffer(string fileName)
        {
            var bytes = ConfManager.LoadConfFile(fileName);
            if (bytes?.Length > 0)
            {
                return new ByteBuffer(bytes);
            }
    
            return null;
        }
    
        protected void CacheIdToIndex(T_KEY id, int index)
        {
            _toi ??= new Dictionary<T_KEY, int>(Count);
            _toi.Add(id, index);
        }
    
        protected abstract void OnCreate();
        
        // Can override methods to do additional data processing
        protected virtual void OnPostCreated() { }

        public T_Info? Get(T_KEY id)
        {
            return null != _toi && _toi.TryGetValue(id, out var index) ? GetByIndex(index) : null;
        }
    
        public abstract T_Info? GetByIndex(int index);
    }
}